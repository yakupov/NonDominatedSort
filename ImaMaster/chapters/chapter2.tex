\chapter{Постановка задачи и описание метода ее решения}
\label{chapter2}

В данной главе описывается новый алгоритм инкрементальной недоминирующей сортировки. Предложенный
метод является развитием идей, заложенных в основу алгоритма \textit{ENLU}, рассмотренного в
предыдущей главе.

\section{Требования, предъявляемые к разрабатываемому алгоритму}
\label{reqs}
Целью данной работы является разработка алгоритма инкрементальной недоминирующей сортировки, позволяющего
выполнять добавление и удаление особи за линейное ($O(N)$, где $N$ - размер популяции) время.

Требования к данной исследовательской работе:
\begin{itemize}
	\item Разработка алгоритма инкрементальной недоминирующей сортировки, корректно работающего
	за линейное время для точек из двумерного пространства;
	\item Доказательство корректности работы алгоритма;
	\item Оценка времени работы алгоритма (в т. ч. доказательство линейного времени работы времени
	работы в худшем случае);
	\item Сравнение с наилучшими известными алгоритмами недоминирующей сортировки (инкрементальными
	и базирующимися на поколениях) на различных видах входных данных.
\end{itemize}

\section{Общее описание алгоритма}
\label{gen_desc}
В данном разделе приведено описание предложенного алгоритма и используемых в нем структур данных.
Структуры данных подробно рассмотрены в секции~\ref{algo-ds}.
Процедура поиска уровня недоминирования, на который требуется добавить точку, 
описана в секции~\ref{algo-lookup}.
Процедура вставки точки описана в секции~\ref{algo-insert}.
Наконец, процедура удаления худшей точки описана в секции~\ref{algo-delete}.

При оценке времени работы алгоритма, мы обозначаем как $N$ общее число точек в структуре уровней
недоминирования. Текущее число уровней недоминирования обозначается как $M$.

\subsection{Структуры данных}
\label{algo-ds}
Для получения линейного время работы при вставке и удалении нам потребовалась структура данных,
позволяющая выполнять следующие операции за $O(\log N)$:
\begin{itemize}
	\item Поиск элемента в контейнере;
	\item Разбиение контейнера на две части по ключу (часть, где все элементы больше ключа, и часть,
	где все элементы меньше или равны ключу);
	\item Объединение контейнеров $C_1$ и $C_2$, где каждый элемент из $C_1$ не больше каждого элемента 
	из $C_2$).
\end{itemize}

Таким требованиям удовлетворяют Декартовы деревья~\cite{cartesian-tree} и Splay-деревья~\cite{splay-tree}.
Для Декартова дерева время работы составляет $O(\log N)$ \emph{с высокой вероятностью}, тогда как 
для Splay-деревьев время $O(\log N)$ \emph{амортизированное}. На практике Декартовы деревья работают несколько 
быстрее и являются проще в реализации, поэтому они
были выбраны для использования в разрабатываемом алгоритмею

Для решения данной задачи была разработана двухуровневая структура данных.
Уровни недоминирования хранятся в двоичном дереве поиска, отсортированные по рангу.
Каждый узел такого \textit{дерева верхнего уровня} также представляет из себя двоичное дерево поиска
\textit{нижнего уровня}, в котором точки (особи) отсортированы по возрастанию первой координаты.

Поскольку для любых двух различных точек $a$ и $b$ либо $a_X > b_X$ и $a_Y \le b_Y$, либо
$a_X < b_X$ и $a_Y \ge b_Y$, все точки дерева нижнего уровня автоматически оказываются отсортированы 
в порядке убывания по второй координате.

В дереве верхнего уровня, помимо самого уровня недоминирования, требуется хранить размер поддерева (что
позволяет определять ранг уровня за $O(\log M)$) и ссылку на следующий уровень недоминирования
(для обеспечения возможности переноса точек на следующий уровень за $O(\log N)$).

Псевдокод для данного ``дерева деревьев'' представлен в листинге~\ref{algo-ds-code}.
Пример дерева деревьем представлен на рис.~\ref{algo-ds-pic}.
\begin{algorithm}[H]
\begin{algorithmic}[1]
\Structure{Solution}
    \State -- точка
    \State $X$~-- первая координата
    \State $Y$~-- вторая координата
\EndStructure
\Structure{LLTNode}
    \State -- узел дерева нижнего уровня
    \State $L: \textsc{LLTNode}$~-- левое поддерево
    \State $R: \textsc{LLTNode}$~-- правое поддерево
    \State $V: \textsc{Solution}$~-- ключ
\EndStructure
\Structure{HLTNode}
    \State -- узел дерева верхнего уровня
    \State $L: \textsc{HLTNode}$~-- левое поддерево
    \State $R: \textsc{HLTNode}$~-- правое поддерево
    \State $N: \textsc{HLTNode}$~-- ссылка на узел - следующий уровень недоминирования
    \State $V: \textsc{LLTNode}$~-- ключ
    \State $S: \textsc{Integer}$~-- размер поддерева
\EndStructure
\end{algorithmic}
\caption{Псевдокод структур данных, используемых в разработанном алгоритме}\label{algo-ds-code}
\end{algorithm}

\begin{figure*}[!t]
\centering
\includegraphics[width=1.0\textwidth]{pic/scheme.1}
\caption{
Предложенная структура данных~-- ``дерево деревьев''. 
Узлы ``дерева верхнего уровня'' соответствуют уровням недоминирования.
Каждый уровень недоминирования представлен в виде ``дерева нижнего уровня'',
узлы которого упорядочены по первой координате. В каждом узле ``дерева верхнего уровня'' 
дополнительно хранится размер поддерева (на рисунке - числа в скобках).
}\label{algo-ds-pic}
\end{figure*}

\subsection{Определение ранга}
\label{algo-lookup}
Имея дерево нижнего уровня $T$ и точку $s$, за $O(\log |T|)$ можно определать, доминирует ли 
хотя бы одна точка из $T$ над $s$. Для этого нужно найти точку $u \in T$, такую что 
$u_X \le s_X$ и $u_X$ наибольшая. Это можно сделать путем обхода дерева $T$ из корня. Если
$u$ найдена и доминирует над $s$, значит, доминирующее решение из $T$ найдено. Иначе,
ни одна точка из $T$ не доминирует над $s$.

Для доказательства корректности данной операции необходимо рассмотреть два случая. Если $u$ не найдена, 
то для любой точки $t \in T$ выполняется условие $t_X > s_X$, то есть $t$ не доминирует над $s$.
Если $u$ найдена, все точки из $T$, отличные от $u$, могут быть разделены на две группы: 
$V = \{ v\,|\,v_X < u_X \}$ и $W = \{ w\,|\,w_X > u_X \}$.
Для каждой точки $v \in V$ также верно $v_Y > u_Y$. Если $u$ не доминирует над $s$, 
выполняется $u_Y > s_Y$, потому что $u_X \le s_X$. Из этого следует, что для каждой точки 
$v \in V$ верно $v_Y > u_Y > s_Y$, то есть ни одна точка из $V$ не может доминировать над $s$. 
В то же время, для любой точки $w \in W$ верно $w_X > s_X$ по построению ($u_X$ максимальна,
при условии что $u_X \le s_X$). Таким образом, ни одна точка из $W$ не может доминитовать над $s$.

Алгоритм, приведенный в листинге~\ref{algo-lookup-code}, позволяет выполнять обход дерева верхнего
уровня и найти уровень недоминирования минимального ранга, который не доминирует над новой точкой $s$.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function{LowLevelDominates}{$T$, $s$}
    \State{-- доминирует ли хоть одна точка из $T$ над $s$?}
    \State{$T: \textsc{LLTNode}$ -- корень дерева нижнего уровня}
    \State{$s: \textsc{Solution}$ -- добавляемая точка}
    \State{$B \gets \textsc{null}$ }
    \While{$T \neq \textsc{null}$}
        \If{$T.V.X \le s.X$}
            \State{$B \gets T$}
            \State{$T \gets T.R$}
        \Else
            \State{$T \gets T.L$}
        \EndIf
    \EndWhile
    \If{$B = \textsc{null}$}
        \State\Return{\textsc{false}}
    \EndIf
    \State\Return{$B.Y < s.Y$ or $B.Y = s.Y$ and $B.X < s.X$}
\EndFunction
\Function{SmallestNonDominatingLayer}{$H$, $s$}
    \State{-- возвращает уровень доминирования наименьнего ранга, ни одна точка }
    \State{-- из которого не доминирует над $s$ $H$, а также ранг найденного уровня.}
    \State{$H: \textsc{HLTNode}$ -- tкорень дерева верхнего уровня}
    \State{$s: \textsc{Solution}$ -- добавляемая точка}
    \State{$I \gets 0$ -- счетчик доминирующих уровней}
    \State{$B \gets \textsc{null}$}
    \While{$H \neq \textsc{null}$}
        \If{$\textsc{LowLevelDominates}(H.V, s)$}
            \State{$I \gets I + H.S$}
            \State{$H \gets H.R$}
            \If{$H \neq \textsc{null}$}
                \State{$I \gets I - H.S$}
            \EndIf
        \Else
            \State{$B \gets H$}
            \State{$H \gets H.L$}
        \EndIf
    \EndWhile
    \State\Return{$(B, I)$}
\EndFunction
\end{algorithmic}
\caption{Псевдокод процедуры определения уровня недоминирования, на который следует добавить точку.}
\label{algo-lookup-code}
\end{algorithm}

Грубая оценка времени работы данного алгоритма составляет $O(\log M \log N)$, где $O(\log M)$ -
оценка времени обхода дерева верхнего уровня, а $O(\log N)$ - оценка времени обхода каждого дерева
нижнего уровня.

Более точная оценка основывается на следующей идее. Есть $k = O(\log M)$ уровней, которые участвовали
в процедуре поиска (и по которым был совершен обход). Пусть их размеры составляют $L_1 \ldots L_k$,
и $L_1 + \ldots + L_k \le N$.
Время обхода уровня размера $L_i$ составляет $O(1 + \log L_i)$ (необходимо добавить 1 на случай
$\log L_i = o(1)$). Общее время работы процедуры поиска уровня составит:
$$O\left(k + \sum_{i=1}^{k}{\log L_i}\right).$$

Согласно неравенству Коши, $\sum_{i=1}^{k}{\log L_i} \le k \log (N / k)$, что дает следующую оценку 
времени работы процедуры поиска уровня недоминирования:
$$O\left(\log M \left(1 + \log{\frac{N}{\log M}}\right)\right),$$
Поскольку $M \le N$ и $\log(N / \log M)$ является $\omega(1)$, данную оценку можно упростить до:
$$O\left(\log M \log{\frac{N}{\log M}}\right).$$

При фиксированном $N$ и переменном $M$ данное выражение достигает максимума при $M = \Theta(N)$.
Таким образом, время работы составит $O((\log N)^2)$ в худшем случае.

\subsection{Вставка}\label{algo-insert}
Имея дерево верхнего уровня $H$ и точку $s$, процедура вставки обновляет $H$, добавляя
$s$ в одно из деревьев нижнего уровня.

Ключевая идея, позволяющая быстро выполнять вставку, состоит в том, что множества точек, переходящих
на следующий уровень, образуют непрерывные участки на исходном уровне, и остаются непрерывными на 
новом уровне. Пример такой ситуации представлен на рис. ~\ref{algo-insert-example}.

\begin{figure}
\centering
\includegraphics[width=1.0\textwidth]{pic/scheme.2}
\caption{
Пример вставки. Точки, которые не переходят на другой уровень изображены белыми. Добавляемая точка - 
черная. Множества точек, перемещенные на другой уровень, изображены серыми. Необходимо заметить, что 
некоторые точки (точки наивысшего ранга, изображены белыми) не явно были перемещены на другой уровень 
недоминирования, поскольку вместо этого был увеличен ранг всего уровня.
}\label{algo-insert-example}
\end{figure}

Псевдокод процедуры вставки приведен на листинге~\ref{algo-insert-code}.
В качестве одной из перемещенных используется дерево нижнего уровня, содержащее точки, которые
требуется переместить на следующий уровень. Изначально данное дерево содержит одну - добавляемую - 
точку.

Уровень, на который необходимо добавить точку, находится с помощью процедуры определения ранга,
описанной в предыдущей секции.

На каждой итерации предложенного алгоритма выполняются следующие действия:
\begin{itemize}
    \item Дерево нижнего уровня текущего ранга делится на три части с помощью
          текущего множества перемещаемых точек $C$ следующим образом:
    \begin{itemize}
        \item ``левая часть'' $T_L$ состоит из всех точек текущего ранга, чья координата
              $X$ меньше или равна наименьшей координате $X$ точек из $C$;
        \item ``средняя часть'' $T_M$ cсостоит из всех точек текущего ранга,
              над которыми доминирует хотя бы одна точка из $C$;
        \item ``правая часть'' $T_R$ состоит из всех точек текущего ранга,
              чья координата $Y$ меньше наименьшего значения координаты $Y$ точек из $C$.
    \end{itemize}
    Корректность такого разделения будет доказана далее в лемме~\ref{contiguous-dominate-contiguous}.
    \item Текущий уровень собирается из $T_L$, $C$ и $T_R$.
    \item Если $T_L$ и $T_R$ пусты, значит, весь текущий уровень доминируется точками из $C$.
          Следовательно, необходимо добавить новый уровень, состоящий из $T_M$, а ранги 
          текущего уровня и всех последующих - увеличить на единицу.
          Такая ситуация является условием остановки алгоритма вставки.
    \item Если $T_M$ пусто, все последующие уровни остаются неизменными.
          Такая ситуация также является условием остановки алгоритма вставки.
    \item В противном случае, $C \gets T_M$, и алгоритм переходит на следующую итерацию.
\end{itemize}
Если после последней итерации множество $C$ остается непусто, оно формирует новый уровень недоминирования
ранга, на единицу большего максимальному рангу точек перед вставкой. Данный уровень уставляется в дерево 
верхнего уровня с максимальным рангом.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function{SplitX}{$T$, $s$}
    \State{-- делит дерево $T$ на две части $L$, $R$}
    \State{-- таким образом, что для любой $l \in L$ верно $l.X \le s.X$}
    \State{-- и для любой $r \in R$ верно $r.X > s.X$}
    \State{$T: \textsc{LLTNode}$}
    \State{$s: \textsc{Solution}$}
\EndFunction
\Function{SplitY}{$T$, $s$}
    \State{-- делит дерево $T$ на две части $L$, $R$}
    \State{-- таким образом, что для любой $l \in L$ верно $l.Y > s.Y$}
    \State{-- и для любой $r \in R$ верно $r.Y \le s.Y$}
    \State{$T: \textsc{LLTNode}$}
    \State{$s: \textsc{Solution}$}
\EndFunction
\Function{Merge}{$L$, $R$}
    \State{-- склеивает деревья $L$ и $R$ при условии что}
    \State{-- для любой $l \in L$ и $r \in R$ верно $l.X < r.X$}
    \State{$L: \textsc{LLTNode}$}
    \State{$R: \textsc{LLTNode}$}
\EndFunction
\Function{Insert}{$H$, $s$}
    \State{-- вставка точки $s$ в дерево верхнего уровня $H$}
    \State{$H: \textsc{HLTNode}$}
    \State{$s: \textsc{Solution}$}
    \State{$C \gets \textsc{new LLTNode}(s)$}
    \State{$(G, i) \gets \textsc{SmallestNonDominatingLayer}(H,s)$}
    \While{$G \neq \textsc{null}$}
        \State{$C_{\min} \gets \mbox{точка с минимальной } x \mbox{ из } C$}
        \State{$C_{\max} \gets \mbox{точка с минимальной } y \mbox{ из } C$}
        \State{$(T_L, T_i) \gets \textsc{SplitX}(G.V, C_{\min})$}
        \State{$(T_M, T_R) \gets \textsc{SplitY}(T_i, C_{\max})$}
        \State{$G.V \gets \textsc{Merge}(T_L, \textsc{Merge}(C, T_R))$}
        \If{$T_M = \textsc{null}$}
            \State\Return{-- больше никакие точки перемещать не требуется}
        \EndIf
        \If{$T_L = \textsc{null}$ and $T_R = \textsc{null}$}
            \State{-- весь текущий уровень доминируется}
            \State{-- необходимо вставить все точки на новый уровень}
            \State{Insert $\textsc{new HLTNode}(T_M)$ after $G$}
            \State\Return
        \EndIf
        \State{$C \gets T_M$}
        \State{$G \gets G.N$}
    \EndWhile
    \State{Вставить $\textsc{new HLTNode}(C)$ после последнего узла в $H$}
\EndFunction
\end{algorithmic}
\caption{
Псевдокод процедуры вставки в дерево верхнего уровня.
}\label{algo-insert-code}
\end{algorithm}

\section{Корректность и время работы}
Для доказательства корректности, в первую очередь, необходимо доказать следующую лемму.

\begin{lemma}
\label{contiguous-dominate-contiguous}
Пусть есть два множества точек в двумерном пространстве $A$ и $B$, такие что:
\begin{itemize}
	\item никакие две точки из $A$ не доминируют друг над другом;
	\item никакие две точки из $B$ не доминируют друг над другом;
	\item каждая точка из $B$ доминируема хотя бы одной точкой из $A$.
\end{itemize}

Пусть $A' \subseteq A$: $\{ a : a \in A, a.X \ge X_A, a.Y \ge Y_A\}$ для некоторых $X_A$ и $Y_A$.
Пусть $B' \subseteq B$: $\{ b : b \in B, \exists a \in A' : a \mbox{ доминирует над } b \}$.

Тогда существуют $X_B$ и $Y_B$, такие что $B' = \{ b : b \in B, b.X \ge X_B, b.Y \ge Y_B\}$.
\end{lemma}

\begin{proof}
Пусть $a_{\min}$ - точка из $A'$ с минимальной координатой $X$.
Пусть $a_{\max}$ - точка из $A'$ с минимальной координатой $Y$.
Пусть $X_A' = a_{\min}.X$ и $Y_A' = a_{\max}.Y$.

Поскольку никакие две точки из $A'$ не доминируют друг над другом, величина $X_M = a_{\max}.X$ 
является наибольшей $X$ среди всех точек из $A'$, а величина $Y_M = a_{\min}.Y$ является
наибольшей $Y$ для всех точек из $A'$.

Очевидно, для любой $b \in B'$ верно $b.X \ge X_A'$, и $b.Y \ge Y_A'$, 
поскольку если хотя бы одно из этих условий не выполняется, $b$ не может быть доминируема какой-либо
точкой из $A'$. Таким образом, $B' \subseteq \{ b : b \in B, b.X \ge X_A', b.Y \ge Y_A'\}$.

Нам необходимо доказать, что каждая точка $b \in B$, для которой верно $b.X \ge X_A'$ и $b.Y \ge Y_A'$, 
также принадлежит $B'$. Доказательство проведем от противного.

Пусть существует $b \in B$, такая что $b.X \ge X_A'$ и $b.Y \ge Y_A'$, но $b \not\in B'$.
По определению, существует $a \in A$, такая что $a$ доминирует над $b$. По определению $B'$, 
$a \notin A'$. Таким образом, либо $a.X < X_A'$, либо $a.Y < Y_A'$.
Рассмотрим оба случая:
\begin{itemize}
    \item Если $a.X < X_A'$, то $a.Y > Y_M$, иначе $a$ доминирует над $a_{\min}$. 
          Следовательно, $b.Y > Y_M$. Тем не менее, $b.X \ge X_A'$, так что
          точка $a_{\min} \in A'$ действительно доминирует над $b$. Противоречие.
    \item Если $a.Y < Y_A'$, то $a.X > X_M$, иначе $a$ доминирует над $a_{\max}$. 
          Следовательно, $b.X > X_M$. Тем не менее, $b.Y \ge Y_A'$, так что
          точка $a_{\max} \in A'$ действительно доминирует над $b$. Противоречие.
\end{itemize}
Поскольку оба случая противоречивы, лемма доказана.
\end{proof}

Иными словами, доказано, что непрерывный фрагмент \textit{i}-го уровня всегда доминирует непрерывный
фрагмент \textit{i+1}-го уровня. Это объясняет корректность разделения уровня на три части и перемещения
среднего фрагмента на следубющий уровень.

\begin{theorem}[Корректность итерации]\label{insert-iteration}
Для каждой итерации $t$ ($t \ge 1$) определим следующие переменные:
\begin{itemize}
	\item $L_i^t$ - уровень ранга $i$;
	\item $S^t$ - ранг уровня, на который добавляются точки;
	\item $C^t$ - множество добавляемых в $L_{s^t}^t$ точек;
\end{itemize}
Пусть $M$ - число уровней перед началом работы алгоритма.

Если изначальная структура уровней недоминирования корректна (т.е. никакая точка из $L_1^1$ 
не доминируется какой-либо другой точкой, и для любычх $k \ge 2$ и $a \in L_k^1$ существует 
$b \in L_{k-1}^1$, которая доминирует над $a$, ни никакие две точки из $L_k^1$ не доминируют 
друг над другом) и $S^1$ выбран функцией \textsc{SmallestNonDominatingLayer}, должны выполняться
следующие условия:
\begin{enumerate}
    \item Число уровней в начале итерации $t$ равно $M$.
    \item Уровни $L_1^t$ \ldots $L_M^t$ образуют корректную структуру уровней недоминирования.
    \item Каждая точка из $C^t$ доминируется хотя бы одной точкой из $L_{S^t - 1}^t$, if $S^t > 1$.
    \item Если $t > 1$, то $S^t = S^{t - 1} + 1$ и существуют $X^t$ и $Y^t$, такие что 
          $C^t = \{c : c \in L_{S^t - 1}^{t - 1}, c.X \ge X^t, c.Y \ge Y^t \}$.
    \item Если $t > 1$, то для любого $1 \le i \le M$, $i \neq S^{t-1}$ верно $L_i^{t-1} = L_i^t$.
\end{enumerate}
\end{theorem}
\begin{proof}
Первое утверждение верно, потому как любое добавление нового уровня влечет за собой остановку 
алгоритма вставки.

Пятое утверждение верно, так как на $t$-й итерации меняется только $S^t$-й уровень.

Остальные утверждения доказываются по индукции. База индукции - $t = 1$, когда:
\begin{itemize}
    \item Второе и третье утверждения верны по определению;
    \item При $t = 1$, четвертое утверждение не проверяется.
\end{itemize}

Пусть данные утверждения верны для $t$.
Следующая итерация будет выполнена, если уровень $L_{S^t}^t$ разделен по минимальным
$X$ и $Y$ из $C^t$ таким образом, что средняя часть $T_M$ непуста, и хотя бы одно из
множеств $T_L$ и $T_R$ также непусто.

Поскольку $C^{t+1} = T_M$, по лемме~\ref{contiguous-dominate-contiguous} значения
$X^{t+1}$ и $Y^{t+1}$ существуют. Условие $S^{t+1} = S^t + 1$ выполяется согласно строке 43
в листинге~\ref{algo-insert-code}. Таким образом, четвертое утверждение верно для $t+1$.

Поскольку $C^{t+1} = T_M$, для любой точки $a \in C^{t+1}$ существует $b \in C^{t}$, такая что 
$b$ доминирует над $a$. Тем не менее, $C^{t} \subset L_{S^t}^{t+1} = L_{S^{t+1}-1}^{t+1}$.
Таким образом, третье утверждение также верно для $t+1$.

Чтобы доказать пятое утверждение, необходимо доказать следующие утверждения:
\begin{itemize}
    \item Никакие две точки из $L_{S^t}^{t+1}$ не доминируют друг над другом. 
          Поскольку $L_{S^t}^{t+1} = T_L \cup C^t \cup T_R$ и $T_L \subset L_{S^t}^{t}$,
          $T_R \subset L_{S^t}^{t}$, необходимо показать что:
    \begin{itemize}
        \item Для любых $a \in C^t$ и $b \in T_L$, $a$ и $b$ не доминируют друг над другом.
              Если $t = 1$, это выполняется по определению $S^t$.
              Иначе, $C^t \subset L_{S^t - 1}^{t-1}$ и $T_R \subset L_{S^t}^{t-1}$ согласно
			  индукционному предположению, и $b$ не может доминировать над $a$. Тем не менее, 
			  $b.X < a.X$ по построению, так что $a$ не может доминировать над $b$.
        \item Для любых $a \in C^t$ и $b \in T_R$, $a$ и $b$ не доминируют друг над другом.
              Данное доказательство симметрично предыдущему.
    \end{itemize}
    \item Для любой $a \in L_{S^t}^{t+1}$ существует $b \in L_{S^t - 1}^{t+1}$, такая что
          $b$ доминирует над $a$. Это выполняется, поскольку $L_{S^t}^{t+1} = T_L \cup C^t \cup T_R$,
          $T_L \subset L_{S^t}^{t}$, $T_R \subset L_{S^t}^{t}$, $L_{S^t}^{t}$ и
          $C^t$ доминируются $L_{S^t - 1}^t$ и $L_{S^t - 1}^{t+1} = L_{S^t - 1}^t$.
    \item Для любой $a \in L_{S^t + 1}^{t+1}$ существует $b \in L_{S^t}^{t+1}$, такая что
          $b$ доминирует над $a$. Поскольку $L_{S^t + 1}^{t+1} = L_{S^t + 1}^t$, для любой $a$
          существует $b' \in L_{S^t}^t$, такая что $b'$ доминирует над $a$.
          Поскольку $L_{S^t}^{t+1} = T_L \cup C^t \cup T_R$, $T_L \subset L_{S^t}^{t}$, 
          $T_R \subset L_{S^t}^{t}$, утверждение верно в случае если $b' \in T_L \cup T_R$.
          Единственная альтернатива - $b' \in T_M$. Тем не менее, для каждой $t \in T_M$
          существует $t' \in C^t$, такая что $t'$ доминирует над $t$, так что $t'$ также 
		  доминирует над $a$.
\end{itemize}

По итогам анализа данных утверждений, теорема доказана.

\end{proof}

\begin{theorem}[Корректность алгоритма]
Если перед выполнением вставки уровни недоминирования образовывали корректную структуру, то 
после завершения работы алгоритма:
\begin{enumerate}
    \item Уровни будут формировать корректную структуру;
    \item Каждая точка, присутствовавшая в структуре до запуска алгоритма,
	      останется в структуре;
    \item Добавляемая точка будет присутствовать в структуре.
\end{enumerate}
\end{theorem}
\begin{proof}
Поскольку при вставке никакие точки не удаляются, второе утверждение верно.

Поскольку добавляемая точка изначально присутствует в множестве перемещаемых точек, она будет 
добавлена в структуру, поскольку алгоритм завершается только в случае, если множество перемещаемых 
точек становится пустым. Таким образом, третье утверждение также верно.

Для доказательства первого утверждения необходимо рассмотреть условия завершения работы алгоритма:
\begin{itemize}
    \item Алгоритм завершает работу на строке 34 листинга~\ref{algo-insert-code}.
          В этот момент отсутствуют решения, которые необходимо добавить на какой-либо уровень.
          По теореме~\ref{insert-iteration}, уровни недоминирования будут формировать корректную
		  структуру.
    \item Алгоритм завершает работу на строке 40 листинга~\ref{algo-insert-code}.
          В этом случае уровень, образованный $C$, целиком доминирует над уровнем, 
		  образованным $T_M = G.V$, который, в свою очередь, доминирует над всеми последующими уровнями
		  (по второму условию теоремы~\ref{insert-iteration}).
		  Таким образом, новый уровень, образованный $T_M$, может быть вставлен после $C$ 
		  без нарушения первого утвердления данной теоремы.
    \item Алгоритм завершает работу на строке 46 листинга~\ref{algo-insert-code}. Перед добавлением
		  нового уровня, все точки из $C$ не доминируют друг над другом, поскольку $C$ либо
          состоит из одной точки, либо представляет из себя фрагмент уровня. К тому же, все точки из $C$
		  доминируются первым уровнем (третье утверждение теоремы~\ref{insert-iteration}).
		  Таким образом, после вставки такого уровня структура уровней недоминирования останется
		  корректной.
\end{itemize}
Теорема доказана, поскольку все условия завершения алгоритма корректны.
\end{proof}

Время работы алгоритма вставки состоит из времени работы алгоритма поиска уровня 
($O(\log M \log (N / \log M))$), а также суммарного времени выполнения всех итераций.

Пусть было выполнено $P \le M$ итераций. Предположим, что уровни $L_1 \ldots L_P$ 
были разделены во время этих итераций. Обозначим размеры этих уровней после разделения как
$L_1^L, L_1^M, L_1^R, \ldots, L_P^L, L_P^M, L_P^R$. Значение $L_0^M = 1$ соответствует 
изначальному состоянию множества $C$ с единственным элементом - добавляемой точкой.

На $i$-й итерации были выполнены следующие операции сложности $\omega(1)$:
\begin{itemize}
    \item Нахождение минимума и максимума $C$ за $O(1 + \log L_{i-1}^M)$;
    \item \textsc{SplitX} за $O(1 + \log(L_i^L + L_i^M + L_i^R))$;
    \item \textsc{SplitY} за $O(1 + \log(L_i^M + L_i^R))$;
    \item Внутренний \textsc{Merge} за $O(1 + \log(L_{i-1}^M + L_i^R))$;
    \item Внешний \textsc{Merge} за $O(1 + \log(L_i^L + L_{i-1}^M + L_i^R))$.
\end{itemize}

Сумма всех значений не превышает $4 \sum_{i=1}^{P}{L_i}$, что дает итоговую сложность $O(N)$. 
По неравенству Коши, сумма времен работы всех итераций составляет $O(P (1 + \log (N/P)))$. 
При фиксированном $N$, эта функция достигает максимума при $P = \Theta(N)$,
когда $O(P (1 + \log(N/P))) = O(M(1+ \log(N/M)))$ и достигается худшее время работы $O(N)$. 
Процедуры вставки новых уровней могут выполняться только в конце алгоритма и требуют лишь $O(\log M)$,
а потому не влияют на асимптотическую сложность

Суммарное время работы алгоритма вставки выглядит следующим образом:
$$O\left(M \left(1 + \log\frac{N}{M}\right) + \log M \log \frac{N}{\log M}\right).$$

\subsection{Удаление худшей точки}
\label{algo-delete}
Большинство алгоритмов многокритериальной оптимизации не требует возможности удаления случайной точки.
Удалять необходимо "худшие" точки, которые хранятся на последнем уровне предложенной структуры данных.
Их можно удалять за $O(\log N + \log M)$.