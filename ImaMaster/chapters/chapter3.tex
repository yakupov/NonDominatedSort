\chapter{Результаты работы алгоритма}
\label{chapter3}

В данной главе проводится сравнение предложенного алгоритма с аналогами и оценка времени его работы 
на различных множествах тестовых данных.

\section{Конфигурация эксперимента}
\label{test_conf}
Было проведено сравнение с ENLU и алгоритмом недоминирующей сортировки, входящим в NSGA-II.
Все алгоритмы тестировались на одном и том же, случайно сгенерированном множестве точек.
Для популяционной сортировки измерялось время сортировки всей популяции. 
Инкрементальные алгоритмы тестировались путем последовательного добавления всех точек в структуру 
данных. Замерялось суммарное время работы всех операций вставки.

Тестирование проводилось на множествах точек размерностей 250, 500, 1000, 2000 и 4000.
Для каждой конфигурации выполнялось по 100 запусков, для каждого запуска множество точек 
генерировалось заново. Время работы алгоритмов вычислялось путем вычитания времени запуска 
алгоритма из времени его завершения. Время старта и время завершения определялись с помощью 
процедуры \textit{java.lang.System.nanoTime()}.

\subsection{Тестовые данные}
Для оценки производительности использовались следующие виды входных данных:
\begin{itemize}
    \item ``квадрат'':   генерируются $N$ случайных точек, равномерно распределенные в квадрате $N \times N$;
    \item ``параллель'': генерируются $N$ случайных точек, $N/2$ из которых лежат на прямой
                        $y = N - x$, а остальные - на $y = N - x + 1$;
    \item ``diag1'':    генерируется последовательность из $N$ точек $(x, x)$,
                        начиная с максимального $x$;
    \item ``diag2'':    генерируется последовательность из $N$ точек, поочередно находящихся на прямых
						$(x, x + 5)$ и $(x + 5, x)$, начиная с максимального $x$;
    \item ``П'':   генерируется ``параллельно-перпендикулярная'' структура (напоминающая 
				   повернутую на 45 градусов кириллическую букву \textsc{П}) следующего вида:
                        $N / 6$ точек на прямой $y = x + 5$,
                        $N / 6$ точек на прямой $y = x - 5$, 
                        $N / 3$ точек на прямой $y = N/3 - x - 4$ и
                        $N / 3$ точек на прямой $y = N/3 - x - 6$.
                   Пример такой структуры приведен на Рис.~\ref{parper-fig}.
\end{itemize}

\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{pic/scheme.3}
\caption{Пример структуры ``П'' при $N = 24$}\label{parper-fig}
\end{figure}

\section{Результаты тестирования}

При оценке производительности измерялось время работы алгоритма, а также суммарное число 
сравнений точек для проверки на доминирование. На большинстве тестов предложенный алгоритм 
показал значительно лучшие результаты чем сравниваемые решения.

Разработанный алгоритм показал худшие результаты были  на данных ``diag1'' и ``diag2''~- 
время работы оказалось сравнимо с ENLU и алгоритмом сортировки из NSGA-II соответственно.

Результаты теста ``diag1'' (Рис. ref{plot-diag1-time}) объявняются тем, что в данном тесте 
каждая вставка происходит на уровень недоминирования минимального ранга. Таким образом, при 
каждой вставке все точки, уже содержащиеся в популяции, увеличивают свой ранг на единицу (то есть,
новая точка доминирует над всей популяцией). Алгоритм ENLU в таком случае определяет ранг за $O(1)$, 
и выполняет вставку нового уровня недоминирования за $O(\log M)$ (при условии хранения уровней 
недоминирования в двоичном дереве поиска - например, в красно-черном дереве). Предложенный 
нами алгоритм в данном случае имеет такую же асимптотическую эффективность.

Результаты теста ``diag2'' (Рис. \ref{plot-diag2-time}) объясняются тем, что алгоритм сортировки 
из NSGA-II в данном случае работает за $O(N^2)$ (это время определяется временем определения ранга,
которое у данного алгоритма постоянно, то есть не зависит от значений точек). 
Предложенный нами алгоритм на таких входных данных достигает худшего случая, так как при каждой 
второй вставке образуется множество точек (размера 1), "выталкивыемых" на следующий уровень 
недоминирования. Таким образом, добавление $N$ точек происходит за $O(N)$, что дает итоговое время 
работы $O(N^2)$ - такое же как для алгоритма сортировки из NSGA-II.

Лучшее время работы (дающее более чем стократное превосходство над алгоритмом ENLU) было достигнуто
на П-образных входных данных при больших размерах популяции. ENLU в таком случае выполняет каждую вставку
за квадратичное время, в то время как предложенный алгоритм даже в худшем случае работает за линейное время.

Многократное превосходство над NSGA-II в тесте ``diag1'' объясняется тем, что предложенный
алгоритм (равно как и ENLU) выполняет каждую вставку за $O(\log M)$, что дает суммарное время работы $O(N \log M)$,
что значительно меньше времени работы NSGA-II, составляющего $O(N^2)$.